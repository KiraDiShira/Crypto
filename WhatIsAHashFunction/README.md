- [Index](https://github.com/KiraDiShira/Crypto#crypto)   

# Cryptographic Tidbits

- [Codes vs chiphers](#codes-vs-chiphers)   
- [Transposition vs substitution](#transposition-vs-substitution)
- [Monoalphabetic vs polyalphabetic](#monoalphabetic-vs-polyalphabetic)
- [Cryptanalysis](#cryptanalysis)

## What is a hash function

A **hash function** is a function that takes an input, which in cryptography we usually refer to as the message, and produces an output that we usually call the **hash**, or the **digest** of the message. In theory, the message can be any length, from a single bit to an unlimited number of bytes. In practice, many hash functions place limits on the message length, so that the length of the message can be incorporated into the hash. But these limits are quite generous. For instance, *SHA-1* allow messages ranging from a single bit to more than two million terabytes. The message digest, on the other hand, is almost always a fairly small and fixed width. Cryptographic digests are typically between 128 and 512 bits. Though, both smaller and larger cryptographic hash functions do exist. For perspective, a 256-bit digest can be written as string of 64 hexadecimal digits, which can be comfortably printed on a single line of text. But even so, the number of possible digests is literally astronomical in size. If we could represent each bit using just a single atom, we would require half the mass of the entire known universe to represent all of the possible 256-bit digests. 

The hash function output is called an **image** of the input. One trait that nearly all hash functions have is that they are many to one mappings, meaning that there are many messages that produce the same hash value. When two messages produce the same digest, it is known as a **hash collision**. The set of all inputs that yield the same output, or the set of all messages that collide with each other, are collectively referred to as the **pre-image**. Even when the maximum size is limited, the size of each pre-image is effectively infinite. For instance, if we had a hash function that limited the message length to just 264 bits, or about half a line of text, there are more possible messages than there are atoms in the known universe. And each additional bit doubles the number of possible messages. 

We need a hash function that leaks as little information about the message as possible. Thus, given a digest, we don't want an adversary to be able to say anything about the message that produced it. We want it to be non-invertable, or so-called **one-way**. Later, we will see that we need it to be very difficult for an attacker to find another message that has the same digest as the original, or even to find any two messages that share the same digest. Another way of saying this is that we want it to be very hard to find hash collisions. 

So without concerning ourselves whether it can actually be built, how would an ideal cryptographic hash function behave? Imagine a black box that has an input where we feed in any message we like. The box also has an output that spits out the digest of the complete message. Now imagine that the contents of the box behave in a way that is completely indistinguishable from a mythical being known as an **oracle**, who, in response to each message, produces a truly random digest subject only to the constraint that any time the same message is input the same digest is output (ideal cryptographic hash function)

To visualize how this could be achieved, at least in principle, the oracle simply maintains a list of every message that has ever been input and the digest associated with it. Then, every time a message is entered, the oracle looks through its list for that exact message. And if it finds it, it merely echoes out the associated digest. But if that exact message is not already in the list, it generates a truly random digest, perhaps by flipping a fair coin for each bid, and then adds the new message digest pair to its list before outputting the digest. Because the value of the digest associated with a particular message does not depend on that message in any way, the messages and their digests are uncorrelated, meaning that there is no pattern that would allow an attacker to take just a digest and define anything about the message that might have produced it. It also means that if they want to find a hash collision, the only thing they can possibly do is carry out a brute force attack and keep trying different messages until they find one that happens to result in the desired digest. 
